// THIS CODE IS PROVIDED AS-IS and the resulting config JSON is targeted for
// standalone Vizceral use.
//
// The following link explains how to run the Vizceral example.  Replace the example
// version of sample_data.json with the configuration generated by this handler
// and you should be able to render the Vizceral service graph.
//
// https://github.com/Netflix/vizceral-example
//
// The following link gives some information about the config format, although
// good documentation on volume handling is hard to find.
//
// https://github.com/Netflix/Vizceral/wiki/How-to-Use#graph-data-format
//
// Algorithm: Walk each tree adding nodes and edges, decorating each with information
//            provided.
//
package vizceral

import (
	"fmt"
	"net/url"
	"strings"
	"time"

	"github.com/kiali/kiali/graph/options"
	"github.com/kiali/kiali/graph/tree"
)

type Metadata struct {
}

type Metrics struct {
	Danger  float64 `json:"danger,omitempty"`
	Warning float64 `json:"warning,omitempty"`
	Normal  float64 `json:"normal,omitempty"`
}

type Connection struct {
	Source   string   `json:"source"`
	Target   string   `json:"target"`
	Metadata Metadata `json:"metadata,omitempty"`
	Metrics  Metrics  `json:"metrics,omitempty"`
}

type Notice struct {
	Title    string `json:"title"`
	Link     string `json:"link,omitempty"`
	Severity int    `json:"severity,omitempty"`
}

type Node struct {
	Renderer    string       `json:"renderer,omitempty"`
	Name        string       `json:"name"`
	DisplayName string       `json:"displayName,omitempty"`
	Class       string       `json:"class,omitempty"`
	Updated     int64        `json:"updated,omitempty"`
	MaxVolume   float64      `json:"maxVolume,omitempty"`
	Metadata    Metadata     `json:"metadata,omitempty"`
	Nodes       []Node       `json:"nodes,omitempty"`
	Connections []Connection `json:"connections,omitempty"`
	Notices     []Notice     `json:"notices,omitempty"`
}

type Config Node

func NewConfig(namespace string, sn *[]tree.ServiceNode, o options.VendorOptions) (result Config) {

	namespaceOrphanNode := Node{
		Renderer:    "focusedChild",
		Name:        "orphan",
		DisplayName: "orphans (no traffic)",
	}

	namespaceNodes := []Node{namespaceOrphanNode}
	var namespaceConnections []Connection
	var maxVolume float64

	for _, t := range *sn {
		walk(&t, &namespaceNodes, &namespaceConnections, &maxVolume, o)
	}

	regionNamespaceNode := Node{
		Renderer:    "region",
		Name:        namespace,
		Updated:     time.Now().Unix(),
		MaxVolume:   maxVolume,
		Nodes:       namespaceNodes,
		Connections: namespaceConnections,
	}

	regionInternetNode := Node{
		Renderer: "region",
		Name:     "INTERNET",
	}
	regionInternetConnection := Connection{
		Source: "INTERNET",
		Target: namespace,
		Metrics: Metrics{
			// TODO, should break up MaxVolume by code from the actual unknown/ingress nodes
			Normal: maxVolume * 1.0,
		},
	}

	regionNodes := []Node{regionInternetNode, regionNamespaceNode}
	regionConnections := []Connection{regionInternetConnection}

	result = Config{
		Renderer:    "global",
		Name:        "edge",
		Nodes:       regionNodes,
		Connections: regionConnections,
	}
	return result
}

func walk(sn *tree.ServiceNode, nodes *[]Node, connections *[]Connection, volume *float64, o options.VendorOptions) {
	name := fmt.Sprintf("%v (%v)", sn.Name, sn.Version)
	_, found := getNode(nodes, name)
	if !found {
		displayName := fmt.Sprintf("%v (%v)", strings.Split(sn.Name, ".")[0], sn.Version)
		n := Node{
			Renderer:    "focusedChild",
			Name:        name,
			DisplayName: displayName,
			Notices: []Notice{
				{
					Title: "Prometheus Graph",
					Link:  linkPromGraph(sn.Name, sn.Version),
				}},
		}
		*nodes = append(*nodes, n)
	}

	isRoot := sn.Metadata["isRoot"] == "true"

	if !isRoot {
		var c Connection
		var source string
		isUnused := sn.Metadata["isUnused"] == "true"
		if isUnused {
			source = "orphan"
		} else {
			source = fmt.Sprintf("%v (%v)", sn.Parent.Name, sn.Parent.Version)
		}
		rate := 0.0
		normal := 0.0
		warning := 0.0
		danger := 0.0
		if !isUnused {
			rate = sn.Metadata["rate"].(float64)
			normal = sn.Metadata["rate_2xx"].(float64) / (rate + 0.0001)
			warning = sn.Metadata["rate_3xx"].(float64) / (rate + 0.0001)
			danger = (sn.Metadata["rate_4xx"].(float64) + sn.Metadata["rate_5xx"].(float64)) / (rate + 0.0001)
			*volume += rate
		}
		c = Connection{
			Source: source,
			Target: name,
			Metrics: Metrics{
				Normal:  normal,
				Warning: warning,
				Danger:  danger,
			},
		}

		*connections = append(*connections, c)
	}

	for _, child := range sn.Children {
		walk(child, nodes, connections, volume, o)
	}
}

func getNode(nodes *[]Node, name string) (*Node, bool) {
	for _, n := range *nodes {
		if n.Name == name {
			return &n, true
		}
	}
	return nil, false
}

func linkPromGraph(name, version string) (link string) {
	// todo: this hardcoded address makes some assumptions...
	address := "http://prometheus-istio-system.127.0.0.1.nip.io"
	var promExpr string
	if tree.UnknownVersion == version {
		promExpr = fmt.Sprintf("istio_request_count{source_service=\"%v\",source_version=\"%v\"}", name, version)
	} else {
		promExpr = fmt.Sprintf("istio_request_count{destination_service=\"%v\",destination_version=\"%v\"}", name, version)
	}
	link = fmt.Sprintf("%v/graph?g0.range_input=1h&g0.tab=0&g0.expr=%v", address, url.QueryEscape(promExpr))
	return link
}
