package business

import (
	"context"
	"sort"
	"sync"

	"k8s.io/apimachinery/pkg/api/errors"

	"github.com/kiali/kiali/config"
	"github.com/kiali/kiali/kubernetes"
	"github.com/kiali/kiali/models"
)

const (
	IstioDefaultCASecret string = "istio-ca-secret"
	UserProvidedCASecret string = "cacerts"
	CACert               string = "ca-cert.pem"
	CAChainCert          string = "cert-chain.pem"
)

type meshDiscovery interface {
	Mesh(ctx context.Context) (*models.Mesh, error)
}

func NewIstioCertsService(conf *config.Config, discovery meshDiscovery, k8s kubernetes.ClientInterface) IstioCertsService {
	return IstioCertsService{
		conf:      conf,
		discovery: discovery,
		k8s:       k8s,
	}
}

type IstioCertsService struct {
	conf      *config.Config
	discovery meshDiscovery
	k8s       kubernetes.ClientInterface
}

func (ics *IstioCertsService) GetCertsInfo(ctx context.Context) ([]models.CertInfo, error) {
	// Return an empty list if the feature is not enabled
	if !ics.conf.KialiFeatureFlags.CertificatesInformationIndicators.Enabled {
		return []models.CertInfo{}, nil
	}

	mesh, err := ics.discovery.Mesh(ctx)
	if err != nil {
		return nil, err
	}

	// Check if there are certificates configured in Istio ConfigMap.
	for _, controlPlane := range mesh.ControlPlanes {
		if controlPlane.Cluster.IsKialiHome {
			if certsConfig := controlPlane.Config.Certificates; certsConfig != nil {
				// If there are, get the certificates generated by Chiron
				certs, err := ics.getChironCertificates(certsConfig)
				if err != nil {
					return nil, err
				}
				return certs, nil
			}
		}
	}

	// Check if there is a user provided secret
	cert, err := ics.getCertificateFromSecret(UserProvidedCASecret, CACert)
	if err == nil {
		return []models.CertInfo{cert}, nil
	}
	if !errors.IsNotFound(err) {
		// Return an error unless the secret is not found (this secret is not mandatory)
		return nil, err
	}

	// Get the default certificate generated by Istio
	cert, err = ics.getCertificateFromSecret(IstioDefaultCASecret, CACert)
	if err != nil {
		return nil, err
	}
	return []models.CertInfo{cert}, nil
}

func (ics *IstioCertsService) getCertificateFromSecret(secretName, certName string) (models.CertInfo, error) {
	cert := models.CertInfo{}
	cert.SecretName = secretName
	cert.SecretNamespace = ics.conf.IstioNamespace

	secret, err := ics.k8s.GetSecret(ics.conf.IstioNamespace, secretName)
	if err != nil {
		if errors.IsForbidden(err) {
			cert.Accessible = false
			return cert, nil
		}
		return models.CertInfo{}, err
	}

	cert.Parse(secret.Data[certName])

	return cert, nil
}

func (ics *IstioCertsService) getChironCertificates(certsConfig []models.Certificate) ([]models.CertInfo, error) {
	wg := sync.WaitGroup{}
	certChan := make(chan models.CertInfo, len(certsConfig))
	errChan := make(chan error, len(certsConfig))

	for _, certConfig := range certsConfig {
		wg.Add(1)
		go func(secretName string, dnsNames []string) {
			defer wg.Done()

			cert, err := ics.getCertificateFromSecret(secretName, CAChainCert)
			if err != nil {
				errChan <- err
				return
			}

			cert.DNSNames = dnsNames
			certChan <- cert
		}(certConfig.SecretName, certConfig.DNSNames)
	}

	wg.Wait()
	close(certChan)
	close(errChan)

	for err := range errChan {
		if err != nil {
			return nil, err
		}
	}

	certs := make([]models.CertInfo, 0)
	for cert := range certChan {
		certs = append(certs, cert)
	}

	sort.Slice(certs, func(i, j int) bool {
		return certs[i].SecretName < certs[j].SecretName
	})

	return certs, nil
}
